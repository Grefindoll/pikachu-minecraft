<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minecraft-like Pikachu World</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #87CEEB;
      font-family: 'Courier New', Courier, monospace;
    }

    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      pointer-events: none;
      user-select: none;
    }

    #blocker {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      flex-direction: column;
      cursor: pointer;
    }

    #instructions {
      font-size: 24px;
      text-align: center;
    }
  </style>
</head>

<body>
  <div id="info">
    <b>操作方法:</b><br>
    W, A, S, D : 移動<br>
    SPACE : ジャンプ<br>
    マウス : 視点移動
  </div>

  <div id="blocker">
    <div id="instructions">
      <span>クリックして開始</span><br>
      <span style="font-size: 16px;">マウスで視点操作、キーボードで移動</span>
    </div>
  </div>

  <!-- Three.js Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- Simplex Noise for terrain generation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

  <script>
    // --- 設定 ---
    const WORLD_WIDTH = 40;
    const WORLD_DEPTH = 40;
    const BLOCK_SIZE = 1;

    // --- グローバル変数 ---
    let camera, scene, renderer;
    let player, playerVelocity, playerOnGround = false;
    let blocks = []; // 衝突判定用
    let keys = {};
    let cameraAngle = 0;
    let cameraVerticalAngle = 0;

    // マウス操作用
    let isLocked = false;
    const blocker = document.getElementById('blocker');
    const instructions = document.getElementById('instructions');

    init();
    animate();

    function init() {
      // シーン設定
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB); // 空の色
      scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

      // カメラ設定
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      // レンダラー設定
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // ライト設定
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
      dirLight.position.set(50, 100, 50);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      dirLight.shadow.camera.left = -50;
      dirLight.shadow.camera.right = 50;
      dirLight.shadow.camera.top = 50;
      dirLight.shadow.camera.bottom = -50;
      scene.add(dirLight);

      // --- 地形生成 (マインクラフト風) ---
      generateTerrain();

      // --- プレイヤー (ピカチュウ風) 生成 ---
      createPlayer();

      // --- イベントリスナー ---
      document.addEventListener('keydown', (e) => keys[e.code] = true);
      document.addEventListener('keyup', (e) => keys[e.code] = false);
      window.addEventListener('resize', onWindowResize);

      // Pointer Lock (マウスキャプチャ)
      blocker.addEventListener('click', function () {
        document.body.requestPointerLock();
      });

      document.addEventListener('pointerlockchange', function () {
        if (document.pointerLockElement === document.body) {
          isLocked = true;
          blocker.style.display = 'none';
        } else {
          isLocked = false;
          blocker.style.display = 'flex';
        }
      });

      document.addEventListener('mousemove', onMouseMove);
    }

    function generateTerrain() {
      const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);

      // 草ブロックのマテリアル（簡易テクスチャ表現）
      const materialTop = new THREE.MeshLambertMaterial({ color: 0x55aa55 }); // 緑
      const materialSide = new THREE.MeshLambertMaterial({ color: 0x8b5a2b }); // 茶色
      const materials = [
        materialSide, materialSide, // Right, Left
        materialTop, materialSide,  // Top, Bottom
        materialSide, materialSide  // Front, Back
      ];

      const simplex = new SimplexNoise();

      for (let x = -WORLD_WIDTH / 2; x < WORLD_WIDTH / 2; x++) {
        for (let z = -WORLD_DEPTH / 2; z < WORLD_DEPTH / 2; z++) {
          // ノイズを使って高さを決める
          let noise = simplex.noise2D(x * 0.1, z * 0.1);
          let height = Math.floor(noise * 3); // -3 ~ 3 の高さ

          // 地面ブロック配置
          // 表面
          const mesh = new THREE.Mesh(geometry, materials);
          mesh.position.set(x * BLOCK_SIZE, height * BLOCK_SIZE, z * BLOCK_SIZE);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          scene.add(mesh);

          // 衝突判定用に保存 (単純化のため、xz座標をキーにして高さを保存)
          blocks.push({
            x: x,
            y: height,
            z: z,
            mesh: mesh
          });

          // 土台（穴が開かないように下のブロックも埋める）
          for (let h = height - 1; h >= -5; h--) {
            if (h === -5) continue; // 底は見えないので省略
            const dirtMesh = new THREE.Mesh(geometry, materialSide);
            dirtMesh.position.set(x * BLOCK_SIZE, h * BLOCK_SIZE, z * BLOCK_SIZE);
            scene.add(dirtMesh);
          }
        }
      }
    }

    function createPlayer() {
      player = new THREE.Group();

      // 色定義
      const yellowMat = new THREE.MeshLambertMaterial({ color: 0xFFDD00 }); // ピカチュウイエロー
      const blackMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
      const redMat = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
      const brownMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });

      // 体 (Body)
      const bodyGeo = new THREE.BoxGeometry(0.5, 0.6, 0.35);
      const body = new THREE.Mesh(bodyGeo, yellowMat);
      body.position.y = 0.3;
      body.castShadow = true;
      player.add(body);

      // 頭 (Head)
      const headGeo = new THREE.BoxGeometry(0.55, 0.5, 0.5);
      const head = new THREE.Mesh(headGeo, yellowMat);
      head.position.y = 0.85;
      head.castShadow = true;
      player.add(head);

      // 耳 (Ears)
      const earGeo = new THREE.BoxGeometry(0.12, 0.4, 0.12);

      const leftEar = new THREE.Mesh(earGeo, yellowMat);
      leftEar.position.set(-0.2, 1.25, 0);
      leftEar.rotation.z = 0.3;
      player.add(leftEar);

      const leftEarTip = new THREE.Mesh(new THREE.BoxGeometry(0.122, 0.1, 0.122), blackMat);
      leftEarTip.position.set(-0.24, 1.45, 0);
      leftEarTip.rotation.z = 0.3;
      player.add(leftEarTip);

      const rightEar = new THREE.Mesh(earGeo, yellowMat);
      rightEar.position.set(0.2, 1.25, 0);
      rightEar.rotation.z = -0.3;
      player.add(rightEar);

      const rightEarTip = new THREE.Mesh(new THREE.BoxGeometry(0.122, 0.1, 0.122), blackMat);
      rightEarTip.position.set(0.24, 1.45, 0);
      rightEarTip.rotation.z = -0.3;
      player.add(rightEarTip);

      // ほっぺ (Cheeks)
      const cheekGeo = new THREE.BoxGeometry(0.1, 0.1, 0.05);
      const leftCheek = new THREE.Mesh(cheekGeo, redMat);
      leftCheek.position.set(-0.2, 0.75, 0.26);
      player.add(leftCheek);

      const rightCheek = new THREE.Mesh(cheekGeo, redMat);
      rightCheek.position.set(0.2, 0.75, 0.26);
      player.add(rightCheek);

      // 顔パーツ (Eyes & Nose)
      const eyeGeo = new THREE.BoxGeometry(0.08, 0.08, 0.05);
      const leftEye = new THREE.Mesh(eyeGeo, blackMat);
      leftEye.position.set(-0.12, 0.9, 0.26);
      player.add(leftEye);

      const rightEye = new THREE.Mesh(eyeGeo, blackMat);
      rightEye.position.set(0.12, 0.9, 0.26);
      player.add(rightEye);

      const nose = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.03, 0.05), blackMat);
      nose.position.set(0, 0.85, 0.26);
      player.add(nose);

      // しっぽ (Tail) - ギザギザ
      const tailGroup = new THREE.Group();
      const tailGeo1 = new THREE.BoxGeometry(0.1, 0.3, 0.05);
      const tail1 = new THREE.Mesh(tailGeo1, brownMat);
      tail1.position.set(0, 0.1, 0);
      tail1.rotation.z = 0.5;
      tailGroup.add(tail1);

      const tailGeo2 = new THREE.BoxGeometry(0.15, 0.3, 0.05);
      const tail2 = new THREE.Mesh(tailGeo2, yellowMat);
      tail2.position.set(0.1, 0.3, 0);
      tail2.rotation.z = -0.5;
      tailGroup.add(tail2);

      const tailGeo3 = new THREE.BoxGeometry(0.2, 0.3, 0.05);
      const tail3 = new THREE.Mesh(tailGeo3, yellowMat);
      tail3.position.set(-0.05, 0.5, 0);
      tail3.rotation.z = 0.3;
      tailGroup.add(tail3);

      tailGroup.position.set(0, 0.4, -0.2);
      player.add(tailGroup);

      // プレイヤー初期位置
      player.position.set(0, 5, 0);
      scene.add(player);

      playerVelocity = new THREE.Vector3();
    }

    function onMouseMove(event) {
      if (!isLocked) return;

      const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
      const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

      cameraAngle -= movementX * 0.005;
      cameraVerticalAngle -= movementY * 0.005;

      // 垂直方向のカメラ制限 (真上/真下になりすぎないように)
      cameraVerticalAngle = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraVerticalAngle));
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function checkCollision(nextPos) {
      // プレイヤーの足元の座標（グリッド座標）
      const px = Math.round(nextPos.x);
      const pz = Math.round(nextPos.z);

      // その座標にある一番高いブロックを探す
      // (簡易的な実装のため、全ブロックを走査していますが、本来はMapなどを使うべきです)
      let groundHeight = -100;

      // 近くのブロックだけ検索
      for (let block of blocks) {
        if (Math.abs(block.x - px) <= 1 && Math.abs(block.z - pz) <= 1) {
          if (block.x === px && block.z === pz) {
            groundHeight = block.y * BLOCK_SIZE + BLOCK_SIZE / 2;
          }
        }
      }

      return groundHeight;
    }

    function animate() {
      requestAnimationFrame(animate);

      const delta = 0.016; // 約60fps想定

      if (isLocked) {
        // --- 移動処理 ---
        const moveSpeed = 0.1;
        const direction = new THREE.Vector3();

        // カメラの向きに合わせて移動方向を計算
        const forward = new THREE.Vector3(Math.sin(cameraAngle), 0, Math.cos(cameraAngle)).normalize();
        const right = new THREE.Vector3(Math.sin(cameraAngle - Math.PI / 2), 0, Math.cos(cameraAngle - Math.PI / 2)).normalize();

        if (keys['KeyW']) direction.add(forward.negate()); // 前
        if (keys['KeyS']) direction.add(forward);          // 後
        if (keys['KeyA']) direction.add(right.negate());   // 左
        if (keys['KeyD']) direction.add(right);            // 右

        // 移動入力がある場合、キャラクターの向きを変える
        if (direction.length() > 0) {
          direction.normalize();
          const targetRotation = Math.atan2(direction.x, direction.z) + Math.PI; // モデルが後ろ向き基準のため調整

          // スムーズな回転
          const currentRotation = player.rotation.y;
          let diff = targetRotation - currentRotation;
          // 角度の正規化
          while (diff > Math.PI) diff -= Math.PI * 2;
          while (diff < -Math.PI) diff += Math.PI * 2;
          player.rotation.y += diff * 0.2;

          player.position.add(direction.multiplyScalar(moveSpeed));
        }

        // --- ジャンプ ---
        if (keys['Space'] && playerOnGround) {
          playerVelocity.y = 0.25; // ジャンプ力
          playerOnGround = false;
        }

        // --- 物理演算 (簡易重力) ---
        playerVelocity.y -= 0.01; // 重力
        player.position.y += playerVelocity.y;

        // --- 接地判定 ---
        // 現在位置の地面の高さを取得
        const groundY = checkCollision(player.position);

        // 地面より下に行ったら補正
        if (player.position.y < groundY) {
          player.position.y = groundY;
          playerVelocity.y = 0;
          playerOnGround = true;
        } else {
          playerOnGround = false;
        }

        // ワールド外に落ちた場合のリセット
        if (player.position.y < -20) {
          player.position.set(0, 10, 0);
          playerVelocity.y = 0;
        }
      }

      // --- カメラ追尾処理 (TPS) ---
      // カメラ位置: キャラクターを中心として球面上に配置
      const distance = 8;
      const camX = player.position.x + distance * Math.sin(cameraAngle) * Math.cos(cameraVerticalAngle);
      const camZ = player.position.z + distance * Math.cos(cameraAngle) * Math.cos(cameraVerticalAngle);
      const camY = player.position.y + distance * Math.sin(cameraVerticalAngle) + 2; // +2は高さオフセット

      camera.position.set(camX, camY, camZ);
      camera.lookAt(player.position.x, player.position.y + 1, player.position.z);

      renderer.render(scene, camera);
    }
  </script>
</body>

</html>